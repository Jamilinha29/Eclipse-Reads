Requisitos do App de Eclipse Reads
1ï¸âƒ£ Funcionalidades Essenciais (MVP â€“ LanÃ§amento Inicial)
ğŸ”‘ AutenticaÃ§Ã£o
- Login e cadastro por e-mail/senha
- Login via Google (Google Sign-In API
- RecuperaÃ§Ã£o de senha por e-mail
- ConfirmaÃ§Ã£o de conta via link no e-mail

ğŸ  PÃ¡gina Inicial
- Lista de livros mais lidos (diÃ¡rio, semanal, mensal)
- â€œBlackboxâ€ de livros em cards verticais e carrossel horizontal
- Pesquisa de livros (por tÃ­tulo, autor, gÃªnero)
ğŸ“š Biblioteca
- VisualizaÃ§Ã£o de todos os livros disponÃ­veis
- Filtros por categoria, formato e status
- AdiÃ§Ã£o de livros Ã  biblioteca pessoal
ğŸ“– Leitor de Livros
- Suporte a mÃºltiplos formatos (EPUB, PDF inicialmente)
- Ajuste de fonte, tamanho e cor de fundo (modo claro/escuro/sÃ©pia)
- Marcadores de pÃ¡ginas
- ContinuaÃ§Ã£o automÃ¡tica de onde parou
- Suporte a leitura offline (download do livro)
ğŸ‘¤ Perfil do UsuÃ¡rio
- Foto e nome de usuÃ¡rio
- Lista de livros â€œLidosâ€, â€œLendoâ€ e â€œQuero Lerâ€
- EstatÃ­sticas bÃ¡sicas de leitura (tempo total, pÃ¡ginas lidas)
2ï¸âƒ£ Funcionalidades AvanÃ§adas (Fase 2 â€“ ApÃ³s MVP)
ğŸ“¢ Rede Social
- Seguir outros leitores
- Sistema de comentÃ¡rios e resenhas
- AvaliaÃ§Ã£o com estrelas
- Feed de atividades de amigos
ğŸ’¾ SincronizaÃ§Ã£o e Backup
- Sincronizar biblioteca e progresso na nuvem (Supabase Firestore ou Realtime Database)
- Login em vÃ¡rios dispositivos mantendo progresso
ğŸ¤– RecomendaÃ§Ãµes Inteligentes
- SugestÃµes baseadas no histÃ³rico do usuÃ¡rio
- Lista personalizada por gÃªnero e autor

Requisitos Adicionais â€“ Mobile N2
Projeto do app mÃ³vel:
 MigraÃ§Ã£o do MVP para Arquitetura 
Moderna
1. Objetivo
Migrar o aplicativo protÃ³tipo (MVP)  para uma arquitetura orientada a 
componentes e padrÃµes atuais, melhorando manutenÃ§Ã£o, testabilidade, 
resiliÃªncia e eficiÃªncia energÃ©tica. 
O novo design adotarÃ¡ MVVM  com V iewModels, persistÃªncia  local com 
Room, comunicaÃ§Ã£o  com servidor via API REST , gestÃ£o de trabalho em 
background  com W orkManager , uso de corrotinas para concorrÃªncia segura 
e estratÃ©gias de detecÃ§Ã£o/recuperaÃ§Ã£o de conectividade.
resumo dos principais requisitos funcionais
â—Introduzir ViewModels  para todas  as telas, isolando lÃ³gica de 
apresentaÃ§Ã£o e expondo estado via LiveData/StateFlow .
â—Implementar cliente de rede  resiliente (ex.: Retrofit + OkHttp)
â—‹timeouts, retry/backof f e cache; suportar fallback entre 
interfaces  (Wi-Fi â†’ mÃ³vel â†’ modo offline).
â—Sincronizar dados com servidor REST
â—‹operaÃ§Ãµes CRUD e sincronizaÃ§Ã£o.
â—Persistir dados localmente com Room
â—‹permitir  modo offline  completo e envio/recepÃ§Ã£o de dados 
quando houver conectividade e consentimento do usuÃ¡rio.
â—Executar tarefas de sincronizaÃ§Ã£o e manutenÃ§Ã£o em background via 
WorkManager , respeitando restriÃ§Ãµes (networkT ype, charging, 
batteryNotLow).
â—Usar Kotlin Coroutines  (scoped com viewModelScope, lifecycleScope, 
workerScope) para concorrÃªncia, cancelamento e composiÃ§Ã£o de 
fluxos assÃ­ncronos.
â—Garantir consentimento do usuÃ¡rio para upload de dados e oferecer 
controles de privacidade explÃ­citos (opt-in/opt-out).
â—Medir e reduzir memory leaks
2. Arquitetura (visÃ£o de alto nÃ­vel)
â—Presentation Layer:  Activities/Fragments + Jetpack Compose (ou 
outro) para renderizar UI; observar V iewModels.
â—ViewModel Layer:  Estado da UI, validaÃ§Ã£o e orquestraÃ§Ã£o de 
chamadas ao Repository
â—Domain/Repository Layer:  RepositÃ³rios que abstraem fontes de 
dados (Network, Local). Aplicam polÃ­ticas de cache, merges e 
regras de negÃ³cio.
â—Data Layer:
â—‹Network:  Retrofit/OkHttp + interceptors (autenticaÃ§Ã£o, 
logging, retry). TLS obrigatÃ³rio.
â—‹Local:  Room + DAOs; entidades versionadas e migraÃ§Ãµes.
â—Background & Scheduling:  WorkManager para jobs 
persistentes; W orkers implementados como CoroutineW orker .
â—Infra & Aux (opcional):   invejaÃ§Ã£o de dependencias a Hilt, 
logging estruturado, Crashlytics para produÃ§Ã£o, monitoring/metrics 
(ex.: Firebase Performance ou alternativa gratuita), LeakCanary 
em dev .
o monstro precisa estar completo
requisitos tÃ©cnicos 
â—conectividade e resiliÃªncia
â—‹Detectar estado de rede com ConnectivityManager e 
NetworkCallback
â—‹EstratÃ©gia de fallback : preferir Wi-Fi; se indisponÃ­vel usar 
mÃ³vel; se nenhuma, operar em modo of fline.
â—‹Enfileirar operaÃ§Ãµes de escrita quando of fline; W orkManager 
tenta envio conforme condiÃ§Ãµes.
â—‹[DesejÃ¡vel] Expor na UI indicador de conectividade, Ãºltima 
sincronizaÃ§Ã£o e estado das filas.
â—SincronizaÃ§Ã£o e polÃ­ticas de dados
â—‹SincronizaÃ§Ã£o incremental  (apenas deltas ou registros 
alterados)
â—‹[DesejÃ¡vel] Conflitos resolvidos pela polÃ­tica configurÃ¡vel (server 
wins / client wins / manual merge via UI).
â—‹[DesejÃ¡vel]  Respeitar limites de taxa (rate limiting) e usar backof f 
exponencial em retries.
â—Energia e performance
â—‹Evitar wake locks manuais
â—‹preferir WorkManager com restriÃ§Ãµes e setExpedited() 
somente para casos urgentes.
â—‹[Boas prÃ¡ticas] Reduzir requisiÃ§Ãµes desnecessÃ¡rias com 
agregaÃ§Ã£o e debounce
â—‹[Boas prÃ¡ticas] PaginaÃ§Ã£o (Paging 3) para listas longas; 
carregamento lazy de imagens via Glide/Coil.
â—SeguranÃ§a e privacidade
â—‹Controle de acesso, login (autenticaÃ§Ã£o/autorizaÃ§Ã£o) 
encriptaÃ§Ã£o e token
â—‹Implementar consentimento explÃ­cito para 
coleta/sincronizaÃ§Ã£o e UI para revogaÃ§Ã£o.
â—‹[DesejÃ¡vel] Todos os requests via HTTPS/TLS; validar 
certificados (Network Security Config)
â—‹[DesejÃ¡vel] Armazenar credenciais com Android Keystore; 
tokens curtos + refresh token seguro
â—‹[DesejÃ¡vel]  Minimizar dados sensÃ­veis armazenados 
localmente; quando necessÃ¡rio, usar criptografia 
(EncryptedSharedPreferences / SQLCipher).
â—GestÃ£o do ciclo de vida e memory leaks
â—‹ViewModels sem referÃªncia a Context/UI
â—‹Usar lifecycle-aware components e cancelar corrotinas via 
scopes apropriados
â—‹Integrar LeakCanary em builds de desenvolvimento para 
detectar vazamentos.
â—Testes e qualidade
â—‹Testes para ViewModels e Repositories (mock de 
network/dao) para garantir o funcionamento bÃ¡sico.
â—Observabilidade (recomendÃ¡vel)
â—‹Integrar Crashlytics (erros), monitoring de performance e 
logs estruturados
â—‹anÃ¡lise de desempenho  (tempo de startup, taxa de 
sucesso de sync, filas pendentes, uso de bateria por feature) 
e telemetria bÃ¡sica (capturar esses logs do uso e enviar pro 
servidor)
EntregÃ¡veis e critÃ©rios de aceitaÃ§Ã£o
â—RepositÃ³rio Git com todo o cÃ³digo, organizaÃ§Ã£o da arquitetura. 
DesejÃ¡vel revisÃ£o de PR.
â—CÃ³digo reestruturado com MVVM e DI
â—‹[a implementaÃ§Ã£o correta da arquitetura Ã© um dos 
pontos-chave da entrega]
â—DocumentaÃ§Ã£o : README com fluxos, diagramas, polÃ­ticas de 
sincronizaÃ§Ã£o e instruÃ§Ãµes de build/deploy , etc
â—MÃ©tricas exibidas (logs/monitoring) dos testes locais e do uso do app 
por parte da equipe 
â—‹desejÃ¡vel integraÃ§Ã£o com Crashlytics.
â—‹Documentar vazamentos detectados por LeakCanary em builds / 
uso do app
â—ApresentaÃ§Ã£o do app:
â—‹funcionamento e jornada do usuÃ¡rio
â—‹explicaÃ§Ã£o da arquitetura implementada
â—‹apresentaÃ§Ã£o da anÃ¡lise de mÃ©tricas
â– devido a dificuldades com uma anÃ¡lise em tempo real, 
mÃ©tricas de desempenho, rede e memÃ³ria podem ser 
apresentadas por vÃ­deo. O grupo pode gravar os testes e 
mostrar a reproduÃ§Ã£o no dia da apresentaÃ§Ã£o
â—ContingÃªncias (ou nÃ£o vou conseguir fazer tudo)
â—‹faÃ§a o que der , o mais longe que conseguir (o Ã³bvio precisa ser dito)
â—‹feito Ã© melhor que perfeito. NÃ£o vou cobrar dÃ­vida tÃ©cnica kkk
â—‹ dito isso, â€œfeitoâ€ sÃ³ salva atÃ© certo ponto: Garanta os 
incontornÃ¡veis: completar a migraÃ§Ã£o pro modelo mvvm, 
implementando todos os componentes da arquitetura no melhor 
que der , mesmo que simples/basicÃ£o
deixemos o perfeito pro android Cell

